<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual 3D Model Viewer</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f0f4f8; }

        /* General container styling for dual layout */
        .model-area {
            width: 100vw;
            height: 50vh; /* Each model takes half the screen height */
            position: relative;
        }
        
        /* Container for the small model (top) */
        #model-container-small {
            background-color: #1a1a2e;
        }

        /* Container for the large model (bottom) */
        #model-container-large {
            background-color: #2e1a3e; /* Different color for distinction */
        }
        
        /* Loading/Interaction Overlay */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* Canvas elements need to fill their parent container */
        canvas {
            display: block;
        }

    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader and OrbitControls for model loading and interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <!-- Container for the Small (6MB) Model - Loads Immediately -->
    <div id="model-container-small" class="model-area">
        <div id="loading-small" class="overlay text-white text-xl p-4 bg-purple-600/80 rounded-lg shadow-lg">
            Loading Small Model (6 MB)...
        </div>
    </div>

    <!-- Container for the Large (37MB) Model - Lazy Loaded (Scroll Activated) -->
    <div id="model-container-large" class="model-area">
        <!-- Loading message/Overlay - Visible initially to prompt scroll, then shows download progress -->
        <div id="loading-large" class="overlay text-white text-xl p-4 bg-red-600/80 rounded-lg shadow-lg">
            Scroll down to load the 37 MB high-detail model...
        </div>
    </div>


    <script>
        // --- 1. CONFIGURATION & GLOBAL STATE ---
        // Store references to all active scenes/controls for the animation loop
        const scenesToRender = []; 

        // **********************************************************************************************
        // URL for the 6MB Model (Loads immediately)
        const URL_SMALL_MODEL = 'https://raw.githubusercontent.com/Maxx-Rev/Festronix-2k25/main/satellite/load.gltf'; 
        
        // URL for the 37MB Model (Lazy Loaded via Scroll)
        const URL_LARGE_MODEL = 'https://raw.githubusercontent.com/Maxx-Rev/Festronix-2k25/main/spaceship/scene.gltf'; 
        // **********************************************************************************************

        // --- 2. CORE SETUP FUNCTION (Reusable for both containers) ---

        /**
         * Sets up a Three.js scene, camera, renderer, and controls in a specific container.
         * @param {string} containerId - The ID of the HTML div element.
         * @param {string} modelUrl - The URL of the GLTF model to load.
         * @param {boolean} lazyLoad - If true, the model is not loaded yet (used for large model).
         */
        function setupScene(containerId, modelUrl, lazyLoad = false) {
            const container = document.getElementById(containerId);
            if (!container) return console.error(`Container ID ${containerId} not found.`);

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(containerId === 'model-container-small' ? 0x1a1a2e : 0x2e1a3e);
            
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1, 5); 

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Append canvas immediately for the small model
            if (!lazyLoad) {
                 container.appendChild(renderer.domElement);
            }

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting Setup (same for both scenes)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            // Store the context
            const context = { scene, camera, renderer, controls, containerId, modelUrl };
            scenesToRender.push(context); // Add to the animation loop list

            // Start loading if not lazy-loaded
            if (!lazyLoad) {
                loadModel(context);
            } else {
                // For the lazy-loaded scene, we only return the context for later use
                return context;
            }
        }

        // --- 3. MODEL LOADING FUNCTION ---
        function loadModel(context) {
            const { scene, modelUrl, containerId } = context;
            const loader = new THREE.GLTFLoader();
            const loadingElement = document.getElementById(`loading-${containerId.split('-').pop()}`);

            // 1. Determine the path (directory) and the file name
            const lastSlashIndex = modelUrl.lastIndexOf('/');
            const basePath = modelUrl.substring(0, lastSlashIndex + 1);
            const filename = modelUrl.substring(lastSlashIndex + 1);

            // 2. Set the path for the loader to find dependent assets (.bin, textures)
            loader.setPath(basePath);
            
            // 3. Load the model
            loader.load(filename,
                // On successful load
                function (gltf) {
                    context.model = gltf.scene;

                    // Calculate the bounding box to center and scale the model
                    const box = new THREE.Box3().setFromObject(context.model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    // Center the model in the scene
                    context.model.position.sub(center);

                    // Optional: Rescale the model
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const desiredSize = 2; 
                    const scaleFactor = desiredSize / maxDim;
                    context.model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    scene.add(context.model);
                    
                    // Hide loading message
                    if(loadingElement) loadingElement.classList.add('hidden');
                    console.log(`Model for ${containerId} loaded successfully.`);
                },
                // On progress (optional)
                function (xhr) {
                    // Custom handling for progress, especially when total is 0 (GitHub Raw)
                    if (xhr.total > 0) {
                        const percent = Math.round(xhr.loaded / xhr.total * 100);
                        if(loadingElement) loadingElement.textContent = `Downloading ${percent}%...`;
                    } else {
                        // Continuous message if size is unknown
                        if(loadingElement) loadingElement.textContent = `Downloading Large Model...`;
                    }
                },
                // On error (ENHANCED ERROR HANDLING)
                function (error) {
                    console.error(`An error occurred loading model for ${containerId}:`, error);
                    let errorMessage = 'Error loading model.';
                    
                    if (error && error.target && (error.target.status === 0 || error.target.status === 404)) {
                        errorMessage = 'Load Failed: File not found or CORS blocked. Check URL.';
                    } else {
                        errorMessage = `Error loading model: ${error.message || 'Unknown issue'}.`;
                    }

                    if(loadingElement) {
                        loadingElement.textContent = errorMessage;
                        loadingElement.classList.remove('bg-red-600/80', 'bg-orange-500/80');
                        loadingElement.classList.add('bg-red-900/90');
                    }
                }
            );
        }

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            scenesToRender.forEach(context => {
                if (context.renderer && context.controls) {
                    context.controls.update();
                    context.renderer.render(context.scene, context.camera);
                }
            });
        }

        // --- 5. INITIALIZATION & EVENTS ---
        
        let largeModelContext;

        window.onload = function () {
            // Load the small model immediately
            setupScene('model-container-small', URL_SMALL_MODEL, false);

            // Initialize the large model scene context
            largeModelContext = setupScene('model-container-large', URL_LARGE_MODEL, true);

            const largeContainer = document.getElementById('model-container-large');
            const loadingLarge = document.getElementById('loading-large');
            
            // Set up Intersection Observer for lazy loading
            let modelLoaded = false;
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    // Check if the target element is visible AND the model hasn't been loaded yet
                    if (entry.isIntersecting && !modelLoaded) {
                        
                        // Stop observing once we start the load
                        observer.unobserve(largeContainer);
                        modelLoaded = true;
                        
                        // 1. Update message/style to indicate active download
                        loadingLarge.textContent = 'Starting 37 MB Download...';
                        loadingLarge.classList.remove('bg-red-600/80');
                        loadingLarge.classList.add('bg-orange-500/80');

                        // 2. Append the renderer canvas to the container (makes the scene renderable)
                        largeContainer.appendChild(largeModelContext.renderer.domElement);

                        // 3. Start the file download
                        loadModel(largeModelContext); 
                    }
                });
            }, {
                // Load when 10% of the element is visible
                threshold: 0.1 
            });

            // Start observing the large model container
            observer.observe(largeContainer);

            // Start the main loop
            animate();
            
            // Event Listener for window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- 6. RESPONSIVE HANDLER ---
        function onWindowResize() {
            scenesToRender.forEach(context => {
                const container = document.getElementById(context.containerId);
                if (container && context.camera && context.renderer) {
                    // Update camera and renderer sizes based on the container's new size
                    context.camera.aspect = container.clientWidth / container.clientHeight;
                    context.camera.updateProjectionMatrix();
                    context.renderer.setSize(container.clientWidth, container.clientHeight);
                }
            });
        }
    </script>
</body>
</html>
