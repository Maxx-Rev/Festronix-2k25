<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Festronix — Cosmic Motion</title>
    <style>
        /* Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        html,
        body {
            height: 100%;
            background: #020217;
            overflow: hidden;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial
        }

        /* Layout */
        .stage {
            position: relative;
            width: 100%;
            height: 100vh;
            display: grid;
            place-items: center;
            background: radial-gradient(1200px 600px at 10% 20%, rgba(62, 16, 90, 0.18), transparent 10%),
                radial-gradient(900px 400px at 85% 80%, rgba(12, 34, 90, 0.12), transparent 8%),
                linear-gradient(180deg, #04031a 0%, #050417 40%, #08102a 100%);
            isolation: isolate;
            cursor: default;
        }

        /* Canvas sits underneath the UI */
        canvas#starsCanvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 0;
        }

        /* Soft nebula glows layered with blend modes */
        .nebula {
            position: absolute;
            inset: 0;
            z-index: 1;
            pointer-events: none;
        }

        .nebula .cloud {
            position: absolute;
            width: 120vmax;
            height: 60vmax;
            filter: blur(60px) saturate(140%);
            mix-blend-mode: screen;
            opacity: 0.55;
            animation: floatCloud 30s linear infinite;
            will-change: transform;
        }

        .cloud.c1 {
            background: radial-gradient(closest-side, rgba(20, 185, 255, 0.12), rgba(10, 10, 40, 0));
            transform: translate(-55%, -46%) rotate(8deg) scaleX(1.2);
            animation-duration: 32s;
        }

        .cloud.c2 {
            background: radial-gradient(closest-side, rgba(160, 50, 200, 0.12), rgba(10, 10, 40, 0));
            transform: translate(-50%, -52%) rotate(-6deg) scaleX(1.0);
            animation-duration: 38s;
            opacity: 0.6;
        }

        .cloud.c3 {
            background: radial-gradient(closest-side, rgba(255, 60, 140, 0.08), rgba(10, 10, 40, 0));
            transform: translate(-45%, -50%) rotate(22deg) scaleX(1.25);
            animation-duration: 45s;
            opacity: 0.45;
        }

        @keyframes floatCloud {
            0% {
                transform: translate(-50%, -50%) rotate(0deg)
            }

            50% {
                transform: translate(-48%, -52%) rotate(3deg)
            }

            100% {
                transform: translate(-50%, -50%) rotate(0deg)
            }
        }

        /* small UI hint bottom-left */
        .hint {
            position: fixed;
            left: 14px;
            bottom: 12px;
            z-index: 4;
            font-size: 12px;
            color: rgba(200, 220, 255, 0.6);
            background: rgba(5, 8, 18, 0.5);
            padding: 8px 10px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            pointer-events: auto;
        }

        /* Responsive tweaks */
        @media (max-width:560px) {
            .hint {
                font-size: 11px;
                padding: 6px 8px
            }

            .logoText {
                letter-spacing: 3px
            }
        }
    </style>
</head>

<body>
    <div class="stage" id="stage">
        <!-- Canvas for stars and shooting stars -->
        <canvas id="starsCanvas"></canvas>

        <!-- Nebula glows -->
        <div class="nebula" aria-hidden="true">
            <div class="cloud c1"></div>
            <div class="cloud c2"></div>
            <div class="cloud c3"></div>
        </div>

        <!-- Center content -->
        <div class="center" aria-hidden="false">
            <div class="hint" id="hint">Move your mouse — subtle parallax • Click to spawn a shooting star</div>
        </div>

        <script>
            /* ---------------------------
               Starfield + Shooting Stars
               ---------------------------
               Canvas draws:
               - many small star particles (twinkling)
               - occasional shooting stars (lines that fade)
               - mouse parallax applied by offsetting star coordinates slightly
            */

            (() => {
                const canvas = document.getElementById('starsCanvas');
                const ctx = canvas.getContext('2d', { alpha: true });
                let w = 0, h = 0, cx = 0, cy = 0;
                let DPR = Math.max(1, window.devicePixelRatio || 1);

                // Configuration
                const STAR_COUNT = 600;        // base star count (scaled with size)
                const STAR_MIN_R = 0.35;
                const STAR_MAX_R = 1.6;
                const TWINKLE_SPEED = 0.02;   // how fast twinkle phase moves
                const SHOOT_PROB = 0.006;     // chance each frame to spawn a shooting star
                const SHOOT_MIN_SPEED = 8;
                const SHOOT_MAX_SPEED = 14;
                const nebulaContainer = document.querySelector('.nebula');
                const PARALLAX_STAR_X = 18;  // Max horizontal star shift (multiplied by DPR)
                const PARALLAX_STAR_Y = 12;  // Max vertical star shift (multiplied by DPR)
                const PARALLAX_NEBULA_X = -4; // Max horizontal nebula shift
                const PARALLAX_NEBULA_Y = -3; // Max vertical nebula shift

                const stage = document.getElementById('stage');
                let mouse = { x: 0, y: 0, px: 0, py: 0 }; // mouse pos (0..1)
                let smoothMouse = { x: 0.5, y: 0.5 };
                const SMOOTH_FACTOR = 0.08; // How fast the smoothed value catches up

                // Star object
                class Star {
                    constructor(x, y, r, alpha, tPhase) {
                        this.x = x;
                        this.y = y;
                        this.r = r;
                        this.baseAlpha = alpha;
                        this.t = tPhase;
                        this.twinkleSpeed = (Math.random() * 0.8 + 0.4) * TWINKLE_SPEED;
                        this.dx = (Math.random() - 0.5) * 0.02;
                        this.z = 0.3 + Math.random() * 0.7;
                        this.hue = Math.random() < 0.7 ? 210 + Math.random() * 40 : 0;
                    }
                }

                // Shooting star object - REPLACED WITH CLASS
                class ShootingStar {
                    constructor(x, y, vx, vy, life, length) {
                        this.x = x;
                        this.y = y;
                        this.vx = vx;
                        this.vy = vy;
                        this.life = life;
                        this.maxLife = life;
                        this.length = length;
                    }
                }

                let stars = [], shoots = [];

                function resize() {
                    DPR = Math.max(1, window.devicePixelRatio || 1);
                    w = canvas.width = Math.round(stage.clientWidth * DPR);
                    h = canvas.height = Math.round(stage.clientHeight * DPR);
                    canvas.style.width = stage.clientWidth + 'px';
                    canvas.style.height = stage.clientHeight + 'px';
                    cx = w / 2; cy = h / 2;
                    // regenerate stars based on new size
                    initStars();
                }

                function generateStarSprites(minR, maxR, count) {
                    const sprites = {};
                    for (let r = minR; r <= maxR; r += 0.5) {
                        const key = r.toFixed(1);
                        const size = r * 2 * DPR + 4; // Add padding
                        const spriteCanvas = document.createElement('canvas');
                        spriteCanvas.width = spriteCanvas.height = size;
                        const sctx = spriteCanvas.getContext('2d');
                        const centerX = size / 2;

                        // Draw the core star
                        sctx.beginPath();
                        sctx.fillStyle = 'rgba(255, 255, 255, 1)'; // Draw max brightness
                        sctx.arc(centerX, centerX, r * DPR, 0, Math.PI * 2);
                        sctx.fill();

                        // Store the canvas image
                        sprites[key] = spriteCanvas;
                    }
                    return sprites;
                }

                let starSprites = {}; // Global variable, near 'stars = []'

                function initStars() {
                    stars = [];
                    const area = (w * h) / (1000 * 1000);
                    const count = Math.round(STAR_COUNT * area * 1.4);
                    starSprites = generateStarSprites(STAR_MIN_R, STAR_MAX_R, 6);
                    for (let i = 0; i < count; i++) {
                        const x = Math.random() * w;
                        const y = Math.random() * h;
                        const r = STAR_MIN_R + Math.random() * (STAR_MAX_R - STAR_MIN_R);
                        const baseAlpha = 0.45 + Math.random() * 0.6;
                        const tPhase = Math.random() * Math.PI * 2;
                        const rQuantized = Math.round((STAR_MIN_R + Math.random() * (STAR_MAX_R - STAR_MIN_R)) * 2) / 2;
                        stars.push(new Star(x, y, rQuantized, baseAlpha, tPhase));
                    }
                }

                // spawn shooting star from random edge
                function spawnShootingStar(manualPos) {
                    // pick random angle across screen; prefer top-left -> bottom-right diagonals
                    const startFrom = Math.random();
                    let x, y, tx, ty, speed;
                    if (manualPos) { // spawned via click - start near mouse, go diagonally
                        const x = manualPos.x * w;
                        const y = manualPos.y * h;

                        // IMPROVED ANGLE: Calculate angle from the click point TOWARDS the center (cx, cy)
                        const angleToCenter = Math.atan2(cy - y, cx - x);

                        // Set the star angle to be mostly away from the center, with a slight random variance.
                        // Add Math.PI to 'angleToCenter' to point AWAY from the center.
                        const ang = angleToCenter + Math.PI + (Math.random() - 0.5) * 0.4;

                        const speed = SHOOT_MIN_SPEED + Math.random() * (SHOOT_MAX_SPEED - SHOOT_MIN_SPEED);
                        const vx = Math.cos(ang) * speed;
                        const vy = Math.sin(ang) * speed;
                        shoots.push(new ShootingStar(x, y, vx, vy, Math.round(40 + Math.random() * 34), 120 + Math.random() * 120));
                        return;
                    }

                    if (startFrom < 0.5) {
                        // from left/top edges
                        if (Math.random() < 0.6) { x = Math.random() * w * 0.2; y = -10 - Math.random() * h * 0.1; }
                        else { x = -10 - Math.random() * w * 0.1; y = Math.random() * h * 0.2; }
                    } else {
                        // from right/top
                        if (Math.random() < 0.6) { x = w + 10 + Math.random() * w * 0.2; y = -10 - Math.random() * h * 0.1; }
                        else { x = w + 10 + Math.random() * w * 0.1; y = Math.random() * h * 0.2; }
                    }
                    // aim roughly across center with some variance
                    const angleToCenter = Math.atan2(cy - y, cx - x) + (Math.random() - 0.5) * 0.6;
                    speed = SHOOT_MIN_SPEED + Math.random() * (SHOOT_MAX_SPEED - SHOOT_MIN_SPEED);
                    const vx = Math.cos(angleToCenter) * speed;
                    const vy = Math.sin(angleToCenter) * speed;
                    shoots.push(new ShootingStar(x, y, vx, vy, Math.round(30 + Math.random() * 45), 90 + Math.random() * 140));
                }

                // Render
                let lastTs = 0;
                function animate(ts) {
                    const dt = Math.min(60, ts - lastTs);
                    lastTs = ts;
                    ctx.clearRect(0, 0, w, h);

                    // compute smoothed mouse pos (Linear Interpolation)
                    const dtFactor = dt / 16; // Use delta time to make smoothing frame-rate independent

                    smoothMouse.x += (mouse.x - smoothMouse.x) * SMOOTH_FACTOR * dtFactor;
                    smoothMouse.y += (mouse.y - smoothMouse.y) * SMOOTH_FACTOR * dtFactor;

                    // compute parallax offset (small)
                    const parx = (smoothMouse.x - 0.5) * PARALLAX_STAR_X * DPR;
                    const pary = (smoothMouse.y - 0.5) * PARALLAX_STAR_Y * DPR;

                    const nebulaParallaxX = (smoothMouse.x - 0.5) * PARALLAX_NEBULA_X;
                    const nebulaParallaxY = (smoothMouse.y - 0.5) * PARALLAX_NEBULA_Y;
                    // Set the CSS transform property
                    nebulaContainer.style.transform = `translate(${nebulaParallaxX}px, ${nebulaParallaxY}px)`;

                    // draw stars
                    for (let i = 0; i < stars.length; i++) {
                        const s = stars[i];
                        // twinkle phase update
                        s.t += s.twinkleSpeed * (dt / 16);
                        const tw = (Math.sin(s.t) + 1) / 2; // 0..1
                        const alpha = Math.max(0.05, Math.min(1, s.baseAlpha * (0.6 + 0.6 * tw)));
                        const parallaxFactor = 1.0 - s.z;
                        const depthFactor = 1.0 - s.z;
                        const x = Math.round(s.x + parx * parallaxFactor * 0.5);
                        const y = Math.round(s.y + pary * parallaxFactor * 0.5);
                        // draw glow for bigger stars
                        if (s.r > 1.2) {
                            const g = ctx.createRadialGradient(x, y, 0, x, y, s.r * 9 * DPR);
                            g.addColorStop(0, `rgba(180,220,255,${(alpha * 0.22).toFixed(3)})`);
                            g.addColorStop(0.4, `rgba(120,200,255,${(alpha * 0.09).toFixed(3)})`);
                            g.addColorStop(1, 'rgba(0,0,0,0)');
                            ctx.fillStyle = g;
                            ctx.beginPath();
                            ctx.arc(x, y, s.r * 9 * DPR, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // core
                        ctx.beginPath();
                        let starColor;
                        if (s.hue === 0) {
                            // Pure White
                            starColor = `rgba(255,255,255,${alpha.toFixed(3)})`;
                        } else {
                            // Tinted color using HSL (Saturation and Lightness fixed, Alpha uses twinkle)
                            const lightness = 80 + s.r * 10; // Slightly brighter larger stars
                            starColor = `hsla(${s.hue}, 100%. ${lightness}%, ${alpha.toFixed(3)})`;
                        }
                        ctx.fillStyle = starColor;
                        ctx.arc(x, y, s.r * DPR, 0, Math.PI * 2);
                        ctx.fill();

                        // tiny drift
                        s.x += s.dx * (dt / 16);
                        if (s.x < -20) s.x = w + 20;
                        if (s.x > w + 20) s.x = -20;
                        if (s.y < -20) s.y = h + 20;
                        if (s.y > h + 20) s.y = -20;
                    }

                    // update and draw shooting stars (lines + glow)
                    for (let i = shoots.length - 1; i >= 0; i--) {
                        const sh = shoots[i];
                        // fade factor
                        const f = sh.life / sh.maxLife;
                        // tail end point
                        const tx = sh.x - sh.vx * (sh.length / 80);
                        const ty = sh.y - sh.vy * (sh.length / 80);

                        // gradient for tail
                        const g = ctx.createLinearGradient(sh.x, sh.y, tx, ty);
                        g.addColorStop(0, `rgba(255,255,255,${(0.95 * f).toFixed(3)})`);
                        g.addColorStop(0.6, `rgba(180,220,255,${(0.35 * f).toFixed(3)})`);
                        g.addColorStop(1, `rgba(100,150,255,${(0.02 * f).toFixed(3)})`);

                        ctx.strokeStyle = g;
                        ctx.lineWidth = 1.8 * DPR;
                        ctx.beginPath();
                        ctx.moveTo(sh.x, sh.y);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        // bright head
                        ctx.beginPath();
                        ctx.fillStyle = `rgba(255,255,255,${(0.98 * f).toFixed(3)})`;
                        ctx.arc(sh.x, sh.y, 2.6 * DPR * Math.min(1.3, f * 1.6), 0, Math.PI * 2);
                        ctx.fill();

                        // update
                        sh.x += sh.vx * (dt / 16);
                        sh.y += sh.vy * (dt / 16);
                        sh.life -= (dt / 16);
                        // remove if life ended or far outside screen
                        if (sh.life <= 0 || sh.x < -200 || sh.x > w + 200 || sh.y < -200 || sh.y > h + 200) {
                            shoots.splice(i, 1);
                        }
                    }

                    // sometimes spawn new shooting star
                    if (Math.random() < SHOOT_PROB) spawnShootingStar();

                    requestAnimationFrame(animate);
                }

                // Mouse handling for parallax and click to spawn star
                function onMouseMove(e) {
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((e.clientX - rect.left) / rect.width) || 0.5;
                    mouse.y = ((e.clientY - rect.top) / rect.height) || 0.5;
                }
                function onTouchMove(e) {
                    if (!e.touches || e.touches.length === 0) return;
                    const t = e.touches[0];
                    onMouseMove({ clientX: t.clientX, clientY: t.clientY });
                }
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('touchmove', onTouchMove, { passive: true });

                // click to spawn shooting star at pointer
                canvas.addEventListener('click', (ev) => {
                    const rect = canvas.getBoundingClientRect();
                    const px = (ev.clientX - rect.left) / rect.width;
                    const py = (ev.clientY - rect.top) / rect.height;
                    spawnShootingStar({ x: px, y: py });
                    // small visual feedback: create a short bright burst by adding 2-3 tiny shoots
                    for (let i = 0; i < 2; i++) {
                        spawnShootingStar({ x: px, y: py });
                    }
                });

                // keyboard toggles: press 's' to spawn a burst
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 's') {
                        spawnShootingStar();
                        spawnShootingStar();
                    }
                });

                // init
                function start() {
                    resize();
                    lastTs = performance.now();
                    requestAnimationFrame(animate);
                }

                window.addEventListener('resize', () => {
                    // throttle resize so it's responsive but not jittery
                    clearTimeout(window._rsz);
                    window._rsz = setTimeout(resize, 120);
                });
                // init mouse center
                mouse.x = 0.5; mouse.y = 0.5;
                start();

                // subtle hint auto-hide after a while
                const hint = document.getElementById('hint');
                setTimeout(() => { hint.style.opacity = '0'; hint.style.transform = 'translateY(6px)'; hint.style.transition = 'all 800ms ease'; }, 4200);
            })();
        </script>
</body>

</html>
